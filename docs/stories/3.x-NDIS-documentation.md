# NDIS Incident Capture Wizard - Implementation Documentation

## Overview

This document provides comprehensive guidance for implementing an NDIS incident capture wizard based on a proven 7-step workflow architecture. The system enables frontline workers to efficiently capture incident reports through a guided process that leverages AI assistance for narrative enhancement and clarification.

## Business Context & Requirements

### Core Business Purpose
- **NDIS incident reporting workflow** designed for frontline support workers
- **7-step guided wizard** that captures incident metadata, multi-phase narratives, and AI-enhanced clarifications
- **Professional report generation** with AI assistance for narrative consolidation and enhancement
- **Non-technical user friendly** - Must work without prior training or technical expertise

### Key Business Requirements
1. **Intuitive workflow** - Frontline workers can complete without training
2. **Multi-phase narrative capture** - Before/During/End/Post-event incident sections
3. **AI-powered clarification** - Dynamic follow-up questions based on initial narrative content
4. **Professional enhancement** - AI consolidates original narratives with clarification answers into polished, professional content
5. **Mock/Live API modes** - Support development with mock data and production with live AI services
6. **Comprehensive review** - Final step shows enhanced narratives with ability to view original content

## System Architecture

### Technology Stack
- **Frontend**: React 18+ with TypeScript, Vite build system
- **State Management**: Zustand for global state management
- **UI Framework**: Tailwind CSS v4+ with shadcn/ui components
- **API Integration**: Unified service layer with mock/live mode switching
- **AI Integration**: N8N workflows for LLM prompt processing
- **Development**: BMAD (Breakthrough Method of Agile Development) workflow

### Core Architectural Components

#### 1. Wizard Framework
Reusable wizard component system that manages multi-step workflows with:
- Progress indicators and step navigation
- Step validation and conditional navigation  
- Loading states and error handling
- Flexible step configuration with validation callbacks

#### 2. State Management Pattern
Centralized Zustand store managing:
- **Incident metadata**: Reporter, participant, date/time, location
- **Multi-phase narratives**: Before/During/End/Post-event sections
- **Clarification Q&A**: Dynamic questions and user answers
- **AI-enhanced content**: Consolidated professional narratives
- **API mode switching**: Mock vs live service configuration
- **Loading and error states**: User feedback and error recovery

#### 3. Service Layer Architecture
Unified API facade with automatic fallback:
- **Mock mode**: Local JSON data for development and testing
- **Live mode**: N8N workflow integration for production AI services
- **Automatic fallback**: Graceful degradation from live to mock on errors
- **Toast notifications**: User feedback for API failures and fallbacks

## Seven-Step Workflow Implementation

### Step 1: Incident Metadata
**Component**: `MetadataInputStep.tsx`
**Purpose**: Capture basic incident information
**Fields**:
- Reporter Name (text input)
- Participant Name (text input)
- Event Date/Time (datetime-local picker)
- Location (text input)
**Validation**: All fields required before proceeding

### Step 2: Multi-Section Narrative Input
**Component**: `NarrativeInputStep.tsx`
**Purpose**: Capture comprehensive incident narrative
**Sections**:
- **Before Event**: Lead-up conditions and context
- **During Event**: The incident itself - actions, behaviors, responses
- **End Event**: How the incident concluded
- **Post-Event Support**: Care and support provided after incident

**API Trigger**: Upon leaving this step, triggers clarification questions generation

### Steps 3-6: Phase-Specific Clarification
**Components**: 
- `BeforeEventClarificationStep.tsx`
- `DuringEventClarificationStep.tsx` 
- `EndOfEventClarificationStep.tsx`
- `PostEventSupportClarificationStep.tsx`

**Purpose**: Present AI-generated clarification questions specific to each narrative phase
**Features**:
- Questions generated based on original narrative content
- Optional answers - users can skip any question
- Questions tailored to participant name, location, and narrative context
- Answers stored separately but linked to original questions

**API Trigger**: Upon leaving each step, triggers narrative consolidation for that phase

### Step 7: Enhanced Review and Submit
**Component**: `IncidentReviewStep.tsx`
**Purpose**: Comprehensive review of complete incident report
**Features**:
- Display all incident metadata
- Show AI-enhanced narratives prominently 
- Toggle to view original narratives
- Consolidation status indicators
- Professional formatting for final review
- Submit/Complete button to finalize report

## State Management Structure

### Core Interfaces

```typescript
export interface IncidentMetadata {
  reporterName: string;
  participantName: string;
  eventDateTime: string;
  location: string;
}

export interface IncidentNarrative {
  beforeEvent: string;
  duringEvent: string;
  endEvent: string;
  postEvent: string;
}

export interface ClarificationQuestion {
  id: string;
  question: string;
  phase: 'beforeEvent' | 'duringEvent' | 'endEvent' | 'postEvent';
}

export interface ClarificationAnswer {
  questionId: string;
  answer: string;
}

export interface NarrativeExtras {
  beforeEvent: string;  // AI-enhanced content
  duringEvent: string;
  endEvent: string;
  postEvent: string;
}
```

### Store Methods
- `updateMetadata(metadata)` - Update incident basic information
- `updateNarrative(narrative)` - Update narrative sections
- `updateClarificationAnswer(phase, questionId, answer)` - Store Q&A responses
- `fetchClarificationQuestionsIfNeeded()` - Smart API call with caching
- `consolidatePhaseNarrative(phase)` - AI enhancement with caching
- `toggleApiMode()` - Switch between mock/live modes
- `populateTestData(panelType)` - Generate realistic test data

## API Integration & Prompt Templates

### 1. Generate Clarification Questions
**Endpoint**: `/generate-clarification-questions`
**Trigger**: After Step 2 (Narrative Input)
**Purpose**: Generate phase-specific follow-up questions

**Input Variables**:
- `participant_name` - Participant's name from metadata
- `reporter_name` - Reporter's name from metadata  
- `event_datetime` - When incident occurred
- `location` - Where incident occurred
- `before_event` - Before event narrative text
- `during_event` - During event narrative text
- `end_of_event` - End event narrative text
- `post_event_support` - Post-event narrative text

**Prompt Template**:
```
You are preparing clarification questions for a previously submitted narrative report.
The incident involved {{ $json.participant_name }}, and was reported by {{ $json.reporter_name }}.
The original event occurred on {{ $json.event_datetime }} at {{ $json.location }}.

Your task is to generate open-ended follow-up questions that help clarify or expand on the original report, broken into four structured sections:

<before_event>
{{ $json.before_event }}
</before_event>

<during_event>
{{ $json.during_event }}
</during_event>

<end_of_event>
{{ $json.end_of_event }}
</end_of_event>

<post_event_support>
{{ $json.post_event_support }}
</post_event_support>

Output your response as valid JSON using the following structure:

{
  "before_event": ["Question 1", "Question 2"],
  "during_event": ["Question 1", "Question 2"],
  "end_of_event": ["Question 1", "Question 2"], 
  "post_event_support": ["Question 1", "Question 2"]
}

Guidelines:
- Provide 2-4 open-ended questions per section
- Focus on clarifying actions, reactions, timing, environment, witnesses
- Use supportive language that encourages reflection
- Handle sensitive content appropriately and respectfully
- Return only JSON output, no extra commentary
```

### 2. Enhance Narrative Content
**Endpoint**: `/enhance-narrative-content`
**Trigger**: After each clarification step (Steps 3-6)
**Purpose**: Consolidate original narrative with clarification answers

**Input Variables** (N8N JavaScript format):
- `phase` - Current phase (beforeEvent, duringEvent, endEvent, postEvent)
- `answers` - Array of {question, answer} objects
- `instruction` - Phase-specific enhancement instructions

**Prompt Template** (N8N JavaScript):
```javascript
const phase = $json.phase || "Unknown Phase";
const instruction = $json.instruction || "No instruction provided.";
const answers = Array.isArray($json.answers) ? $json.answers : [];

const narrativeFacts = answers
  .filter(item =>
    item.question && item.question.trim() !== "" &&
    item.answer   && item.answer.trim()   !== ""
  )
  .map(item => `Q: ${item.question.trim()}\nA: ${item.answer.trim()}`);

const prompt = `
You are a report-writing assistant.

For the "${phase}" phase of an incident, you have the following answered clarification questions.

For each one:
- Keep the original question.
- Respond with the answer on the next line.
- Lightly clean up the grammar of the answer, but keep the original tone and phrasing.
- Do not summarize or rewrite the response.
- Do not include unanswered questions.

Details:
${narrativeFacts.join('\n\n')}

Instruction:
${instruction}
`.trim();
```

### 3. Generate Mock Answers
**Endpoint**: `/generate-mock-answers`
**Trigger**: Test data generation (development feature)
**Purpose**: Create realistic test answers for clarification questions

**Input Variables**:
- `participant_name` - From incident metadata
- `reporter_name` - From incident metadata
- `location` - From incident metadata
- `phase` - Current phase being tested
- `phase_narrative` - Original narrative for context
- `questions` - Array of question objects to answer

**Prompt Template**:
```
You are generating realistic mock answers for clarification questions about an NDIS incident report.

The incident involved {{ $json.participant_name }}, and was reported by {{ $json.reporter_name }}.
The event occurred at {{ $json.location }}.

You are generating answers specifically for the {{ $json.phase }} phase of the incident.

<phase_narrative>
{{ $json.phase_narrative }}
</phase_narrative>

Based on the narrative context above, provide realistic and detailed answers to the following clarification questions. The answers should:
- Be consistent with the narrative provided
- Sound like they come from someone who witnessed the incident
- Include specific details that would be helpful for incident documentation
- Be professional but conversational in tone
- Vary in length (some brief, some more detailed)

Questions to answer:
{{ $json.questions }}

Output as JSON:
{
  "answers": [
    {
      "question_id": "question-id-here",
      "question": "The original question text",
      "answer": "Detailed realistic answer here"
    }
  ]
}
```

### 4. Analyze Contributing Conditions
**Endpoint**: `/analyze-contributing-conditions`  
**Trigger**: Epic 5 Analysis workflow (future enhancement)
**Purpose**: Analyze completed incidents for patterns and contributing factors

**Input Variables**:
- `reporter_name` - Staff member who reported
- `participant_name` - Individual involved in incident
- `event_datetime` - When incident occurred
- `location` - Where incident took place
- `before_event` + `before_event_extra` - Original + enhanced before narratives
- `during_event` + `during_event_extra` - Original + enhanced during narratives  
- `end_of_event` + `end_of_event_extra` - Original + enhanced end narratives
- `post_event_support` + `post_event_support_extra` - Original + enhanced post-event narratives

**Prompt Template** (N8N JavaScript):
```javascript
const prompt = `You are reviewing a narrative report from ${reporterName} about an incident involving ${participantName} on ${eventDateTime} at ${location}.

Incident Inputs

What was happening in the lead-up to the incident?
before_event:
<before_event>${beforeEvent}</before_event>
<before_event_extra>${beforeEventExtra}</before_event_extra>

What occurred during the incident itself?
during_event:
<during_event>${duringEvent}</during_event>
<during_event_extra>${duringEventExtra}</during_event_extra>

How did the incident conclude?
end_of_event:
<end_of_event>${endOfEvent}</end_of_event>
<end_of_event_extra>${endOfEventExtra}</end_of_event_extra>

What support or care was provided in the two hours after the event?
post_event_support:
<post_event_support>${postEventSupport}</post_event_support>
<post_event_support_extra>${postEventSupportExtra}</post_event_support_extra>

Your task
Identify and summarise the immediate contributing conditions — any meaningful patterns, responses, support gaps, or participant behaviours that contributed to the occurrence or escalation of this specific incident.

Response Format:
\`\`\`
**Immediate Contributing Conditions**

### [Condition Name 1]
- [Specific supporting detail from the report]
- [Another relevant observation]

### [Condition Name 2]  
- [Specific supporting detail]
\`\`\`

Only include items clearly supported by the data.
Focus on immediate relevance to this incident.`;
```

## Implementation Guidelines

### File Structure
```
src/
├── routes/
│   └── IncidentCapture.tsx          # Main wizard orchestration
├── components/
│   ├── MetadataInputStep.tsx        # Step 1: Basic info form
│   ├── NarrativeInputStep.tsx       # Step 2: 4-section narrative
│   ├── BeforeEventClarificationStep.tsx   # Step 3: Before clarifications
│   ├── DuringEventClarificationStep.tsx   # Step 4: During clarifications  
│   ├── EndOfEventClarificationStep.tsx    # Step 5: End clarifications
│   ├── PostEventSupportClarificationStep.tsx # Step 6: Post-event clarifications
│   ├── IncidentReviewStep.tsx       # Step 7: Final review
│   └── wizard/
│       ├── Wizard.tsx               # Core wizard framework
│       ├── ProgressIndicator.tsx    # Step progress display
│       ├── StepHeader.tsx           # Step title and actions
│       ├── types.ts                 # Wizard type definitions
│       └── useWizardStore.ts        # Wizard state management
├── store/
│   └── useIncidentStore.ts          # Complete incident state management (775+ lines)
├── lib/services/
│   ├── incident-api.ts              # Unified API facade
│   ├── providers/
│   │   ├── mock-incident-api.ts     # Mock implementation
│   │   └── n8n-incident-api.ts      # N8N/live implementation
│   └── types/
│       ├── api-types.ts             # API interface definitions
│       └── incident-types.ts        # Business object types
└── components/ui/
    ├── button.tsx                   # shadcn/ui button component
    ├── card.tsx                     # shadcn/ui card component
    ├── input.tsx                    # shadcn/ui input component
    ├── textarea.tsx                 # shadcn/ui textarea component
    └── [other ui components]
```

### Development Workflow (BMAD Method)

#### 1. Story Creation Phase
- Create detailed story documentation in `docs/stories/{Epic}.{Story}.story.md`
- Include complete acceptance criteria and technical requirements
- Define implementation tasks and development context
- **Stop here when asked to "create a story" - await user approval**

#### 2. Implementation Phase  
- **Only proceed when explicitly asked to implement**
- Follow story's technical guidance and acceptance criteria
- Use existing project conventions and architectural patterns
- Implement all functional requirements systematically

#### 3. Definition of Done Checklist
- Use comprehensive 57-item DOD checklist for story completion
- Cover requirements, coding standards, testing, functionality verification
- Run linting and type checking: `npm run lint` and `npm run build`
- **Never mark story complete without completing DOD checklist**

#### 4. Commit Process
- Create descriptive commit message with story reference
- Include standard Claude Code footer
- **Always ask user approval before committing**

#### 5. Next Story Planning
- Identify next logical story in epic progression
- Create new story documentation following same process

### Key Implementation Patterns

#### Wizard Step Configuration
```typescript
const steps: WizardStep[] = [
  { 
    id: 'basic-info', 
    title: 'Basic Info', 
    component: Step1,
    isValid: isMetadataComplete  // Validation function
  },
  { 
    id: 'narrative', 
    title: 'Narrative', 
    component: Step2,
    isValid: isNarrativeComplete,
    onLeave: fetchClarificationQuestionsIfNeeded  // API trigger
  },
  // ... Steps 3-6 with consolidation triggers
  { id: 'review', title: 'Review', component: Step7 },
];
```

#### API Service Pattern  
```typescript
export class IncidentAPI implements IIncidentAPI {
  private mode: 'mock' | 'live';
  
  async getClarificationQuestions(narrative, metadata) {
    try {
      return this.mode === 'mock' 
        ? await this.mockAPI.getClarificationQuestions(narrative, metadata)
        : await this.liveAPI.getClarificationQuestions(narrative, metadata);
    } catch (error) {
      // Auto-fallback to mock with toast notifications
      if (this.mode === 'live') {
        showApiErrorToast('generate-clarification-questions', error.message);
        return await this.mockAPI.getClarificationQuestions(narrative, metadata);
      }
      throw error;
    }
  }
}
```

#### State Management Pattern
```typescript
export const useIncidentStore = create<IncidentState>((set, get) => ({
  report: initialReport,
  
  updateMetadata: (metadata) =>
    set((state) => ({
      report: {
        ...state.report,
        metadata: { ...state.report.metadata, ...metadata },
      },
    })),
    
  fetchClarificationQuestionsIfNeeded: async () => {
    const state = get();
    const currentHash = hashNarrative(state.report.narrative);
    
    // Skip if questions exist and narrative unchanged
    if (state.clarificationQuestions && state.lastNarrativeHash === currentHash) {
      return;
    }
    
    // API call with loading states and error handling
    // ... implementation
  },
}));
```

## Essential Reference Files

### Documentation (Business Requirements)
- **Epic Definition**: Complete business requirements for 7-step wizard
- **Story Cards**: Detailed implementation stories (typically 13+ stories for full implementation)  
- **Product Requirements**: User experience specifications and acceptance criteria
- **Architecture Guide**: System design decisions and technical constraints

### Implementation (Code Structure)
- **Main Route**: Wizard orchestration and step configuration
- **State Store**: Complete state management with TypeScript interfaces (typically 700+ lines)
- **Wizard Framework**: Reusable wizard components and navigation (5+ files)
- **Step Components**: 7 individual step implementations with validation

### API Integration (Service Layer)
- **Unified API**: Service facade with mock/live switching and fallback
- **Prompt Templates**: 4 LLM prompt templates with interpolation variables
- **HTTP Examples**: Complete API request/response examples
- **Type Definitions**: TypeScript interfaces for all API contracts

### Supporting Infrastructure
- **Toast Notifications**: User feedback system for API operations
- **UI Components**: shadcn/ui component library integration
- **Styling System**: Tailwind CSS v4+ configuration and custom styles
- **Development Tools**: Test data generation and debugging utilities

## Best Practices & Considerations

### User Experience
- **Progressive Enhancement**: Each step builds on previous information
- **Smart Caching**: Avoid redundant API calls when inputs haven't changed
- **Graceful Fallbacks**: Always provide mock alternatives when live services fail
- **Clear Feedback**: Loading states, error messages, and success confirmations
- **Accessibility**: Proper form labels, focus management, keyboard navigation

### Technical Architecture  
- **Type Safety**: Comprehensive TypeScript interfaces throughout
- **Error Boundaries**: Graceful error handling and recovery
- **Performance**: Lazy loading, memoization, and efficient re-renders
- **Testability**: Mock data, test utilities, and isolated components
- **Maintainability**: Clear separation of concerns and consistent patterns

### Development Workflow
- **Story-Driven**: Each feature implemented through detailed story cards
- **Incremental**: Build and validate each step before proceeding
- **Quality Gates**: Linting, type checking, and manual testing requirements
- **User Approval**: Explicit confirmation before committing changes
- **Documentation**: Maintain comprehensive implementation notes

This implementation provides a robust, production-ready NDIS incident capture system that combines intuitive user experience with powerful AI assistance for professional report generation.

## Complete File Reference List

### Source Repository Structure
**Base Path**: `/Users/davidcruwys/dev/ad/appydave/appydave-app-a-day/001-ndis-incident-report/`

### Documentation Files (Business Requirements & Architecture)

#### Epic and Story Documentation
```
docs/epic-4.md                     # Complete 7-step wizard business requirements
docs/stories/4.1.story.md         # Story: Implement Metadata Input Step  
docs/stories/4.2.story.md         # Story: Multi-Section Narrative Input & Pre-fetch
docs/stories/4.3.story.md         # Story: "Before Event" Clarification Step
docs/stories/4.4.story.md         # Story: "During Event" Clarification Step
docs/stories/4.5.story.md         # Story: "End of Event" Clarification Step
docs/stories/4.6.story.md         # Story: "Post-Event Support" Clarification Step
docs/stories/4.7.story.md         # Story: Test Data Pre-Population Button
docs/stories/4.8.story.md         # Story: Enhanced Test Data with Clarification Answers
docs/stories/4.9.story.md         # Story: Refactor Narrative Field Names for API Alignment
docs/stories/4.10.story.md        # Story: N8N API Integration Foundation
docs/stories/4.11.story.md        # Story: Consolidate Narratives with AI
docs/stories/4.12.story.md        # Story: Enhanced Review and Complete Step
docs/stories/4.13.story.md        # Story: Enhanced Consolidation UX & Controls
docs/stories/5.1.story.md         # Story: Epic 5 Analysis workflow stories
docs/stories/5.2.story.md         # Story: Epic 5 Analysis workflow stories
```

#### Architecture and Requirements
```
docs/prd.md                        # Product requirements document
docs/architecture.md               # Overall system design
docs/tech-stack.md                # Technology decisions and rationale
docs/front-end-architecture-summary.md  # React SPA architecture patterns
docs/project-structure.md         # Codebase organization guide
docs/data-models.md               # Business object specifications
docs/api-reference.md             # API endpoint documentation
docs/environment-vars.md          # Configuration and environment setup
```

#### Development Guidelines
```
CLAUDE.md                         # Claude Code development instructions (BMAD workflow)
docs/operational-guidelines.md    # Development and deployment processes
docs/component-view.md            # Component architecture overview
docs/sequence-diagrams.md         # Workflow sequence documentation
```

### Core Implementation Files

#### Main Application Routes
```
src/App.tsx                       # Root application component
src/main.tsx                      # Application entry point
src/routes/IncidentCapture.tsx    # Main 7-step wizard orchestration (102 lines)
src/routes/Home.tsx               # Application home page
src/routes/IncidentAnalysis.tsx   # Epic 5 analysis workflow route
```

#### Wizard Framework Components
```
src/components/wizard/Wizard.tsx               # Core wizard framework (94 lines)
src/components/wizard/ProgressIndicator.tsx   # Step progress display
src/components/wizard/StepHeader.tsx          # Step title and action bar
src/components/wizard/types.ts                # Wizard TypeScript interfaces
src/components/wizard/useWizardStore.ts       # Wizard navigation state
src/components/wizard/index.ts                # Wizard exports
```

#### Seven Step Components
```
src/components/MetadataInputStep.tsx                  # Step 1: Basic info form (119 lines)
src/components/NarrativeInputStep.tsx                # Step 2: 4-section narrative
src/components/BeforeEventClarificationStep.tsx     # Step 3: Before clarifications
src/components/DuringEventClarificationStep.tsx     # Step 4: During clarifications
src/components/EndOfEventClarificationStep.tsx      # Step 5: End clarifications
src/components/PostEventSupportClarificationStep.tsx # Step 6: Post-event clarifications
src/components/IncidentReviewStep.tsx               # Step 7: Final review and submit
```

#### State Management
```
src/store/useIncidentStore.ts     # Complete incident state management (775 lines)
src/store/useAnalysisStore.ts     # Epic 5 analysis state management
src/store/README.md               # State management documentation
```

#### API Service Layer
```
src/lib/services/incident-api.ts                    # Unified API facade (298 lines)
src/lib/services/providers/mock-incident-api.ts     # Mock implementation
src/lib/services/providers/n8n-incident-api.ts      # N8N/live implementation  
src/lib/services/types/api-types.ts                 # API interface definitions
src/lib/services/types/incident-types.ts            # Business object types
src/lib/services/smart-test-data.ts                 # Test data generation
```

#### UI Components Library
```
src/components/ui/button.tsx      # shadcn/ui button component
src/components/ui/card.tsx        # shadcn/ui card component  
src/components/ui/input.tsx       # shadcn/ui input component
src/components/ui/textarea.tsx    # shadcn/ui textarea component
src/components/ui/label.tsx       # shadcn/ui label component
src/components/ui/progress.tsx    # shadcn/ui progress component
src/components/ui/dialog.tsx      # shadcn/ui dialog component
src/components/ui/alert.tsx       # shadcn/ui alert component
src/components/ui/toast.tsx       # shadcn/ui toast component
```

#### Application-Specific UI Components  
```
src/components/ui/LoadingOverlay.tsx           # Modal loading states
src/components/ui/ErrorDisplay.tsx            # Error handling display
src/components/ui/ApiModeToggle.tsx           # Mock/Live mode switcher
src/components/ui/ToastRegistrar.tsx          # Toast notification system
src/components/ui/MetadataDisplay.tsx         # Metadata review display
src/components/ui/EnhancedNarrativeDisplay.tsx # AI-enhanced content display
src/components/ui/QADisplay.tsx               # Q&A review display
src/components/ui/ConsolidationSummary.tsx    # Consolidation status
src/components/ui/PhaseConsolidationStatus.tsx # Phase-specific status
```

#### Layout and Navigation
```
src/components/layout/AppLayout.tsx       # Main application shell
src/components/layout/CommandPalette.tsx  # Command palette modal
src/components/layout/SettingsModal.tsx   # Settings and preferences
src/components/layout/index.ts            # Layout exports
```

### API Integration Files

#### LLM Prompt Templates
```
docs/api/requests/generate-clarification-questions-prompt.txt  # Clarification Q generation
docs/api/requests/enhance-narrative-content-prompt.txt         # Narrative enhancement
docs/api/requests/generate-mock-answers-prompt.txt            # Mock answer generation
docs/api/requests/analyze-contributing-conditions-prompt.txt  # Conditions analysis
```

#### API Request Examples
```
docs/api/requests/generate-clarification-questions.http       # HTTP request examples
docs/api/requests/generate-clarification-questions.json      # Sample request/response
docs/api/requests/enhance-narrative-content.http             # HTTP request examples
docs/api/requests/enhance-narrative-content.json            # Sample request/response
docs/api/requests/generate-mock-answers.http                 # HTTP request examples
docs/api/requests/generate-mock-answers.json                # Sample request/response
docs/api/requests/analyze-contributing-conditions.http       # HTTP request examples
docs/api/requests/analyze-contributing-conditions.json      # Sample request/response
```

#### API Documentation
```
docs/api/n8n-integration.md          # N8N workflow integration guide
docs/api/epic-5-analysis-api.md      # Epic 5 analysis API specifications
docs/N8N_SERVER_CONFIG.md            # N8N server configuration guide
```

### Supporting Infrastructure Files

#### Styling and Configuration
```
src/index.css                    # Global styles and Tailwind CSS v4 configuration
tailwind.config.js              # Tailwind CSS configuration
src/lib/utils.ts                 # Utility functions
src/lib/utils/toast-notifications.ts  # Toast notification utilities
src/lib/utils/narrativeParser.ts      # Narrative parsing utilities
```

#### Hooks and Patterns
```
src/hooks/useIncidentStoreWithToast.ts  # Store integration with notifications
src/hooks/useStepConsolidation.ts       # Step consolidation logic
src/lib/hooks/useTheme.ts               # Theme management
src/patterns/progressive-enhancement.ts  # Progressive enhancement pattern
```

#### Configuration and Setup
```
src/lib/config/api-config.ts     # API configuration management
src/vite-env.d.ts                # Vite TypeScript declarations
package.json                     # Dependencies and scripts
vite.config.ts                   # Vite build configuration
tsconfig.json                    # TypeScript configuration
.gitignore                       # Git ignore patterns
```

#### Analysis Workflow (Epic 5)
```
src/features/analysis/components/ReviewNarrativeStep.tsx     # Analysis step 1
src/features/analysis/components/ContributingConditionsStep.tsx # Analysis step 2
src/features/analysis/components/ConditionsEditor.tsx       # Conditions editing
src/features/analysis/components/NarrativeDisplay.tsx       # Narrative display
src/features/analysis/hooks/useAnalysisPrefetch.ts         # Analysis prefetching
```

#### Development and Testing
```
src/lib/mock-data/                    # Mock data scenarios directory
src/lib/services/smart-test-data.ts   # Intelligent test data generation
docs/screenshots/                     # UI screenshots and documentation
docs/wizard-ideas/                    # Design concepts and wireframes (20 image files)
```

### Total File Count Summary
- **Documentation Files**: ~35 files (requirements, architecture, stories)
- **Core Implementation**: ~45 files (components, routes, state management)
- **API Integration**: ~15 files (services, prompts, examples)  
- **Supporting Infrastructure**: ~20 files (styles, config, utilities)
- **UI Components**: ~25 files (shadcn/ui + custom components)

**Total Reference Files**: ~140 files comprising the complete NDIS incident capture wizard implementation.

### Key File Priorities for Replication

#### Essential Core (Must Have)
1. `src/routes/IncidentCapture.tsx` - Main workflow orchestration
2. `src/store/useIncidentStore.ts` - Complete state management (775 lines)
3. `src/components/wizard/Wizard.tsx` - Reusable wizard framework
4. `src/lib/services/incident-api.ts` - Unified API with fallback (298 lines)
5. Seven step components (`MetadataInputStep.tsx` through `IncidentReviewStep.tsx`)

#### API Integration (Must Have)
1. All 4 prompt template files in `docs/api/requests/`
2. `src/lib/services/providers/` - Mock and N8N implementations
3. `src/lib/services/types/` - TypeScript API interfaces

#### Documentation (Highly Recommended)
1. `docs/epic-4.md` - Complete business requirements
2. `docs/stories/4.*.story.md` - Implementation story cards (13 files)
3. `CLAUDE.md` - BMAD development workflow
4. `docs/prd.md` - Product requirements

This comprehensive file listing provides exact paths and context for every component needed to replicate the NDIS incident capture wizard system in another repository.